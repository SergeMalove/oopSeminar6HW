# Задание
Взять реализованный код в рамках семинара 4 и продемонстрировать применение принципов, усвоенных на семинаре.  
Нужно в проекте прокомментировать участки кода, которые рефакторим, какой принцип применяем и почему.  

Формат сдачи: ссылка на гитхаб проект

### Комментарий:
Ввиду того, что возможности наглядно показать принципы SOLID  на примере заданий 4го семинара я не нашел   возможным, по этому я решил создать собственную структуру данных.  

## Описание решения

Для описания принципов за основу взято описание шахматных фигур.  

### SPR - Принцип
Для этого создан базовый абстрактынй класс Figure, который сразу же реализует два интерфейса Movable и Eatable. Второй   интерфейс при этом можно и не делать на самом деле, т.к. в данном случае этот метод по умолчанию одинаковый для всех  фигур и реализуется тут же в классе Figure. На основе класса Figure созданы 6 классов наследников, описывающих 6 разных  фигур (King, Queen, Rook, Bishop,Knight, Pawn). В каждом из классов, включая базовый класс Figure реализуется только один  метод. Таким образом, выполняется условие принципа SRP - У класса должна быть только одна причина для изменения.  Т.е. один класс - один метод.
### OCP - Принцип
Исходя из описания первого принципа выше, за счет наследования и применения интерфейсов есть возможность  расширения функционала фигур, путем добваления интерфейсов например. При этом, к сожалению мне не удалось до  конца реализовать идею расширения функционала двух фигур Короля и Ладьи, так как эти фигуры могут выполнять  рокировку. Соотвествующий интерфейс был создан и имплементирован к каждой из фигур, тем самым расширяя из  функционал, однако технически я к сожалению не до конца понял как можно это реализовать. Тем не менее -  программные сущности  открыты для расширения, но закрыты для модификации.
### LSP - Принцип
Так как все конкретные фигуры наследуются от базового класса Figure, то можно легко создавать переменные базового  класса, при этом сохраняя в них объекты конкретного класса наследника, т.е. конкретной фигуры. Тем самым реализуется  принцип - функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа  не зная об этом. Пример этого показан в методе Main.
### ISP - Принцип
Созданы три разлчных интерфейса реализующих три рахных метода для описания трех разных поведений объекта. Таким  образом реализуется принцип - много интерфейсов, специально предназначенных для клиентов, лучше, чем один  интерфейс общего назначения.
### DIP - Принцип
Для демонстрации этого принципа было создано два варианта, т.к. он достаточно сложен для понимания, и возможно я так  же не совсем его понимаю. Тем не менее, создан отдельный класс FigureManager внтури которого, создается поле типа  Figure и уже с этим объектом происходят все взаимодейстия. В принципе, если я правильно понянимаю механизм работы,  то класс Figure реализует интерфейсы Movable и Eatable, таким образом на всех классах наследников от него все равно  будет вызываться метод с конкретной реализацией каждого класс. Все равно, что если бы было поле интерфейса и  вызывался бы метод этого интерфейса. Тем не менее для демонстрации этого я сделал еще один класс MovableManager.  Работа обоих классов показана в методе Main, тем не менее, хоть удалось реализовать это все и оно работает и даже в  какой-то степени понять механизм работы, но в данном кокретном случае реализация такая по какому-то отдельному  интерфейсу в данной конкретной задаче с шахматами выглядит не очень уместной.
